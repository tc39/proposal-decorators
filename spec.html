<!doctype html>
<meta charset="utf8">
<pre class=metadata>
title: Decorators proposal
stage: 2
contributors: Daniel Ehrenberg, Jeff Morrison, Kevin Smith, Kevin Gibbons, Yehuda Katz, Brian Terlson
</pre>
<style>
emu-example figure {
  align-items: initial;
  width: 100%;
}

emu-note {
  display: block;
  border-left-color: #474747;
}

emu-note span.note {
  display: inline-block;
  color: #fff;
  background-color: #474747;
  width: initial;
  padding-right: 50px;
}

emu-note div.note-contents {
  padding-left: 5px;
}

emu-note[type=editor] {
  border-left-color: #900;
}
emu-note[type=editor] span.note {
  background-color: #900;
}

emu-example {
  border-left: 5px solid #006387;
  margin: 1em 0;
}

emu-example figure figcaption:first-child {
  display: inline-block;
  color: #fff;
  background-color: #006387;
  margin: 0;
  padding: 0 50px 0 5px;
  font-weight: normal;
  text-transform: uppercase;
  margin-left: -5px;
}

emu-example figure figcaption:nth-child(2) {
  margin: 0;
  padding: 0;
  padding-left: 5px;
  margin-left: -5px;
  font-size: 20px;
  font-weight: bold;
  margin-bottom: 10px;
}

emu-example p:nth-of-type(1) {
  margin-top: 0;
}

emu-example figure {
  padding-left: 5px;
  display: block;
  margin: 0;
}

emu-example pre {
  margin: 0;
}
</style>

<emu-intro id=sec-intro>
  <h1>Introduction</h1>
  <p>This proposal adds decorators to JavaScript. It incorporates features needed to make decorators work with the <a href="https://tc39.github.io/proposal-class-fields">class fields</a> and <a href="https://tc39.github.io/proposal-private-methods/">private methods</a>. See <a href="https://github.com/tc39/proposal-decorators">the explainer</a> for an overview.</p>

  <p>This document is phrased as a diff against the previous <a href="https://tc39.github.io/proposal-private-methods">private methods</a> proposal, which is in turn a diff against the <a href="https://tc39.github.io/proposal-class-fields">class fields</a> proposal.</p>
</emu-intro>


<emu-clause id=sec-syntax>
  <h1>Syntax</h1>

  <emu-clause id=sec-new-syntax>
    <h1>New Productions</h1>

    <emu-grammar>
      DecoratorList[Yield, Await] :
        DecoratorList[?Yield, ?Await]? Decorator[?Yield, ?Await]

      Decorator[Yield, Await] :
        `@` DecoratorMemberExpression[?Yield, ?Await]
        `@` DecoratorCallExpression[?Yield, ?Await]

      DecoratorMemberExpression[Yield, Await] :
        IdentifierReference[?Yield, ?Await]
        DecoratorMemberExpression[?Yield, ?Await] `.` IdentifierName
        `(` Expression[+In, ?Yield, ?Await] `)`

      DecoratorCallExpression[Yield, Await] :
        DecoratorMemberExpression Arguments[?Yield, ?Await]
    </emu-grammar>
  </emu-clause>

  <emu-clause id=sec-updated-syntax>
    <h1>Updated Productions</h1>

    <emu-grammar>
      ClassElement[Yield, Await] :
        <ins>DecoratorList[?Yield, ?Await]?</ins> MethodDefinition[?Yield, ?Await]
        <ins>DecoratorList[?Yield, ?Await]?</ins> `static` MethodDefinition[?Yield, ?Await]
        <ins>DecoratorList[?Yield, ?Await]?</ins> FieldDefinition[?Yield, ?Await] `;`
        <ins>DecoratorList[?Yield, ?Await]?</ins> `static` FieldDefinition[?Yield, ?Await] `;`

      ClassDeclaration[Yield, Await, Default] :
        <ins>DecoratorList[?Yield, ?Await]?</ins> `class` BindingIdentifier[?Yield, ?Await] ClassTail[?Yield, ?Await]
        [+Default] <ins>DecoratorList[?Yield, ?Await]?</ins> `class` ClassTail[?Yield, ?Await]

      ClassExpression[Yield, Await] :
        <ins>DecoratorList[?Yield, ?Await]?</ins> `class` BindingIdentifier[?Yield, ?Await]? ClassTail[?Yield, ?Await]

      ExportDeclaration :
        `export` `*` FromClause `;`
        `export` ExportClause FromClause `;`
        `export` ExportClause `;`
        `export` VariableStatement[~Yield, ~Await]
        `export` Declaration[~Yield, ~Await]
        `export` `default` HoistableDeclaration[~Yield, ~Await, +Default]
        `export` `default` ClassDeclaration[~Yield, ~Await, +Default]
        `export` `default` [lookahead &lt;! {`function`, `async` [no |LineTerminator| here] `function`, `class`, <ins>`@`</ins>}] AssignmentExpression[+In, ~Yield, ~Await] `;`
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-syntax-early-errors">
    <h1>Static Semantics: Early Errors</h1>
    <emu-grammar>
        DecoratorList[?Yield, ?Await]? MethodDefinition[?Yield, ?Await]
    </emu-grammar>
    <ul>
      <li>
        It is a Syntax Error if |DecoratorList| is present and PropName of |MethodDefinition| is `"constructor"`.
      </li>
    </ul>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-new-ecmascript-specification-types">
  <h1>New ECMAScript Specification Types</h1>

  <emu-clause id="sec-classes-specification-types">
    <h1>Classes Specification Types</h1>

    <emu-clause id="sec-elementdescriptor-specification-type" aoid=ElementDescriptor>
      <h1>The ElementDescriptor Specification Type</h1>

      <p>
        The <dfn>ElementDescriptor</dfn> is a Record used to represent class elements at runtime.
        Values of the ElementDescriptor type are Record values whose fields are defined as by <emu-xref href="#table-element-descriptor-fields"></emu-xref>.
        Unless otherwise specified, every field is always present.
      </p>

      <emu-table id="table-element-descriptor-fields" caption="ElementDescriptor fields">
        <table>
          <thead>
            <tr> <th>Field Name</th>      <th>Value</th>                                                          </tr>
          </thead>
          <tbody>
            <tr> <td>[[Kind]]</td>        <td>One of `"method"`, `"accessor"`, `"field"` or `"hook"`</td>          </tr>
            <tr> <td>[[Key]]</td>         <td>A Property Key or %PrivateName% object</td>                          </tr>
            <tr> <td>[[Descriptor]]</td>  <td>A Property Descriptor</td>                                           </tr>
            <tr> <td>[[Placement]]</td>   <td>One of `"static"`, `"prototype"`, or `"own"`</td>                    </tr>
            <tr> <td>[[Initializer]]</td> <td>A function or ~empty~. This field can be absent.</td>                </tr>
            <tr> <td>[[Start]]</td>       <td>A function. This field can be absent.</td>                           </tr>
            <tr> <td>[[Replace]]</td>     <td>A function. This field can be absent.</td>                           </tr>
            <tr> <td>[[Finish]]</td>      <td>A function. This field can be absent.</td>                           </tr>
            <tr> <td>[[Decorators]]</td>  <td>A List of ECMAScript language values. This field can be absent.</td> </tr>
          </tbody>
        </table>
      </emu-table>

      <p>
        In addition, given an ElementDescriptor _element_, the following conditions are always respected:
        <ul>
          <li>If _element_.[[Kind]] is `"method"` or `"accessor"`, then
            <ul>
              <li>_element_.[[Initializer]] is absent.</li>
              <li>_element_.[[Start]] is absent.</li>
              <li>_element_.[[Replace]] is absent.</li>
              <li>_element_.[[Finish]] is absent.</li>
            </ul>
          </li>
          <li>
            If _element_.[[Kind]] is `"field"`, then
            <ul>
              <li>_element_.[[Initializer]] is present.</li>
              <li>_element_.[[Start]] is absent.</li>
              <li>_element_.[[Replace]] is absent.</li>
              <li>_element_.[[Finish]] is absent.</li>
              <li>_element_.[[Descriptor]]'s [[Get]], [[Set]], and [[Value]] slots are absent.</li>
            </ul>
          </li>
          <li>
            If _element_.[[Key]] is a Private Name, then
            <ul>
              <li>_element_.[[Placement]] is `"own"` or `"static"`.</li>
              <li>_element_.[[Descriptor]].[[Enumerable]] is *false*.</li>
              <li>_element_.[[Descriptor]].[[Configurable]] is *false*.</li>
              <li>_element_.[[Start]] is absent.</li>
              <li>_element_.[[Replace]] is absent.</li>
              <li>_element_.[[Finish]] is absent.</li>
            </ul>
          </li>
          <li>
            If _element_.[[Kind]] is `"hook", then
            <ul>
              <li>_element_.[[Key]] absent.</li>
              <li>_element_.[[Descriptor]] is absent.</li>
              <li>_element_.[[Initializer]] is absent.</li>
              <li>At least one of _element_.[[Start]], _element_.[[Replace]], and _element_.[[Finish]] is present.</li>
              <li>_element_.[[Replace]] and _element_.[[Finish]] are not both present.</li>
              <li>_element_.[[Decorators]] is absent.</li>
            </ul>
          </li>
          <li>
            If _element_.[[Kind]] is `"method"`, then
            <ul>
              <li>IsDataDescriptor(_element_.[[Descriptor]]) is *true*.</li>
            </ul>
          </li>
          <li>
            If _element_.[[Kind]] is `"accessor"`, then
            <ul>
              <li>IsAccessorDescriptor(_element_.[[Descriptor]]) is *true*.</li>
            </ul>
          </li>
        </ul>
      </p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-internal-algorithms">
<h1>Class algorithms</h1>

  <emu-clause id="runtime-semantics-class-definition-evaluation" aoid="ClassDefinitionEvaluation">
    <h1>Runtime Semantics: ClassDefinitionEvaluation</h1>
    <p>With parameters _className_ and _decorators_.</p>
    <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody? `}`</emu-grammar>
    <emu-alg>
      1. Let _lex_ be the LexicalEnvironment of the running execution context.
      1. Let _classScope_ be NewDeclarativeEnvironment(_lex_).
      1. Let _classScopeEnvRec_ be _classScope_'s EnvironmentRecord.
      1. If _className_ is not *undefined*, then
        1. Perform _classScopeEnvRec_.CreateImmutableBinding(_className_, *true*).
      1. <ins>Let _outerPrivateEnvironment_ be the PrivateNameEnvironment of the running execution context.</ins>
      1. <ins>Let _classPrivateEnvironment_ be NewDeclarativeEnvironment(_outerPrivateEnvironment_).</ins>
      1. <ins>Let _classPrivateEnvRec_ be _classPrivateEnvironment_'s EnvironmentRecord.</ins>
      1. <ins>If |ClassBody_opt| is present, then</ins>
        1. <ins>For each element _dn_ of the PrivateBoundNames of |ClassBody_opt|,</ins>
          1. <ins>Perform _classPrivateEnvRec_.CreateImmutableBinding(_dn_, *true*).</ins>
      1. If |ClassHeritage_opt| is not present, then
        1. Let _protoParent_ be the intrinsic object %ObjectPrototype%.
        1. Let _constructorParent_ be the intrinsic object %FunctionPrototype%.
      1. Else,
        1. Set the running execution context's LexicalEnvironment to _classScope_.
        1. Let _superclass_ be the result of evaluating |ClassHeritage|.
        1. Set the running execution context's LexicalEnvironment to _lex_.
        1. ReturnIfAbrupt(_superclass_).
        1. If _superclass_ is *null*, then
          1. Let _protoParent_ be *null*.
          1. Let _constructorParent_ be the intrinsic object %FunctionPrototype%.
        1. Else if IsConstructor(_superclass_) is *false*, throw a *TypeError* exception.
        1. Else,
          1. Let _protoParent_ be ? Get(_superclass_, `"prototype"`).
          1. If Type(_protoParent_) is neither Object nor Null, throw a *TypeError* exception.
          1. Let _constructorParent_ be _superclass_.
      1. Let _proto_ be ObjectCreate(_protoParent_).
      1. If |ClassBody_opt| is not present, let _constructor_ be ~empty~.
      1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.
      1. If _constructor_ is ~empty~, then
        1. If |ClassHeritage_opt| is present and _protoParent_ is not *null*, then
          1. Let _constructor_ be the result of parsing the source text
            <pre><code class="javascript">constructor(... args){ super (...args);}</code></pre>
            using the syntactic grammar with the goal symbol |MethodDefinition[~Yield]|.
        1. Else,
          1. Let _constructor_ be the result of parsing the source text
            <pre><code class="javascript">constructor( ){ }</code></pre>
            using the syntactic grammar with the goal symbol |MethodDefinition[~Yield]|.
      1. Set the running execution context's LexicalEnvironment to _classScope_.
      1. <ins>Set the running execution context's PrivateNameEnvironment to _classPrivateEnvironment_.</ins>
      1. Let _constructorInfo_ be the result of performing DefineMethod for _constructor_ with arguments _proto_ and _constructorParent_ as the optional _functionPrototype_ argument.
      1. Assert: _constructorInfo_ is not an abrupt completion.
      1. Let _F_ be _constructorInfo_.[[Closure]].
      1. If |ClassHeritage_opt| is present and _protoParent_ is not *null*, then set _F_.[[ConstructorKind]] to `"derived"`.
      1. Perform MakeConstructor(_F_, *false*, _proto_).
      1. Perform MakeClassConstructor(_F_).
      1. Perform CreateMethodProperty(_proto_, `"constructor"`, _F_).
      1. If |ClassBody_opt| is not present, let <del>_methods_</del><ins>_elements_</ins> be a new empty List.
      1. Else, let <del>_methods_</del><ins>_definitions_</ins> be <del>NonConstructorMethodDefinitions</del><ins>NonConstructorElementDefinitions</ins> of |ClassBody|. <ins>NOTE: Simply renaming this internal algorithm will be enough; it includes fields.</ins>
      1. <ins>Let _elements_ be a new empty List.</ins>
      1. For each |ClassElement| <del>_m_</del><ins>_d_</ins> in order from <del>_methods_</del><ins>_definitions_</ins>,
        1. <del>If IsStatic of _m_ is *false*, then</del>
          1. <del>Let _status_ be the result of performing PropertyDefinitionEvaluation for _m_ with arguments _proto_ and *false*.</del>
        1. <del>Else,</del>
          1. <del>Let _status_ be the result of performing PropertyDefinitionEvaluation for _m_ with arguments _F_ and *false*.</del>
        1. <ins>Let _newElement_ be the result of performing ClassElementEvaluation for _d_ with arguments _F_, _true_, and ~empty~.</ins>
        1. If <del>_status_</del><ins>_newElement_</ins> is an abrupt completion, then
          1. Set the running execution context's LexicalEnvironment to _lex_.
          1. <ins>Set the running execution context's PrivateNameEnvironment to _outerPrivateEnvironment_.</ins>
          1. Return Completion(_status_).
        1. <ins>Append _newElement_ to _elements_</ins>
      1. <ins>Set _elements_ to CoalesceClassElements(_elements_).</ins>
      1. <ins>If _decorators_ is not provided, let _decorators_ be a new empty List.</ins>
      1. <ins>Let _decorated_ be ? DecorateClass(_elements_, _decorators_).</ins>
      1. <ins>Perform ? AssignPrivateNames(_decorated_.[[Elements]]).
      1. Set the running execution context's LexicalEnvironment to _lex_.
      1. <ins>Set the running execution context's PrivateNameEnvironment to _outerPrivateEnvironment_.</ins>
      1. If _className_ is not *undefined*, then
        1. Perform _classScopeEnvRec_.InitializeBinding(_className_, _F_).
      1. <ins>Set the value of _F_'s [[Elements]] internal slot to _decorated_.[[Elements]].</ins>
      1. <ins>Return ? InitializeClassElements(_F_, _proto_).</ins>
      1. <del>Return _F_</del>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-default-method-descriptor" aoid="DefaultMethodDescriptor">
    <h1>DefaultMethodDescriptor ( key, closure, enumerable, placement )</h1>
    <emu-alg>
      1. Perform SetFunctionName(_closure_, _key_).
      1. If _key_ is a Private Name,
        1. Set _enumerable_ to *false*.
        1. Let _configurable_ be *false*.
        1. Let _writable_ be *false*.
        1. If _placement_ is `"prototype"`, set _placement_ to `"own"`.
      1. Else,
        1. Let _configurable_ be *true*.
        1. Let _writable_ be *true*.
      1. Let _desc_ be the PropertyDescriptor{[[Value]]: _closure_, [[Writable]]: _writable_, [[Enumerable]]: _enumerable_, [[Configurable]]: _configurable_}.
      1. Return the ElementDescriptor { [[Kind]]: `"method"`, [[Key]]: _key_, [[Descriptor]]: _desc_, [[Placement]]: _placement_ }
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-method-definitions-runtime-semantics-propertydefinitionevaluation">
    <h1>Runtime Semantics: ClassElementEvaluation</h1>
    <p>With parameters _homeObject_, _enumerable_ and _placement_.</p>
    <p>ClassElementEvaluation returns an ElementDescriptor Record.</p>
    <emu-see-also-para op="PropertyDefinitionEvaluation"></emu-see-also-para>
    <emu-grammar>ClassElement : <ins>DecoratorList?</ins> MethodDefinition</emu-grammar>
    <emu-alg>
      1. If |DecoratorList| is present, let _decorators_ be the result of performing DecoratorListEvaluation of |DecoratorList|.
      1. Let _element_ be ? ClassElementEvaluation of |MethodDefinition| with arguments ! Get(_homeObject_, `"prototype"`), _enumerable_, and `"prototype"`.
      1. If |DecoratorList| is present, set _element_.[[Decorators]] to _decorators_.
      1. Return _element_.
    </emu-alg>
    <emu-grammar>ClassElement : <ins>DecoratorList?</ins> `static` MethodDefinition</emu-grammar>
    <emu-alg>
      1. If |DecoratorList| is present, let _decorators_ be the result of performing DecoratorListEvaluation of |DecoratorList|.
      1. Let _element_ be ? ClassElementEvaluation of |MethodDefinition| with arguments _homeObject_, _enumerable_ and `"static"`.
      1. If |DecoratorList| is present, set _element_.[[Decorators]] to _decorators_.
      1. Return _elements_.
    </emu-alg>
  <emu-grammar>ClassElement : <ins>DecoratorList?</ins> `static` FieldDefinition `;`</emu-grammar>
  <emu-alg>
      1. If |DecoratorList| is present, let _decorators_ be the result of performing DecoratorListEvaluation of |DecoratorList|.
      1. Let _element_ be ? ClassFieldDefinitionEvaluation of FieldDefinition with parameters `"static"` and _homeObject_.
      1. If |DecoratorList| is present, set _element_.[[Decorators]] to _decorators_.
      1. Return _element_.
  </emu-alg>

  <emu-grammar>ClassElement : <ins>DecoratorList?</ins> FieldDefinition `;`</emu-grammar>
  <emu-alg>
      1. If |DecoratorList| is present, let _decorators_ be the result of performing DecoratorListEvaluation of |DecoratorList|.
      1. Let _element_ be ? ClassFieldDefinitionEvaluation of FieldDefinition with parameters `"own"` and ! Get(_homeObject_, `"prototype"`).
      1. If |DecoratorList| is present, set _element_.[[Decorators]] to _decorators_.
      1. Return _element_.
  </emu-alg>

    <emu-grammar>ClassElement : MethodDefinition</emu-grammar>
    <emu-alg>
      1. Return ClassElementEvaluation of |MethodDefinition| with arguments ! Get(_homeObject_, `"prototype"`),_enumerable_, and `"prototype"`.
    </emu-alg>
    <emu-grammar>ClassElement : `static` MethodDefinition</emu-grammar>
    <emu-alg>
      1. Return ClassElementEvaluation of |MethodDefinition| with arguments _homeObject_, _enumerable_ and `"static"`.
    </emu-alg>
    <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
    <emu-alg>
      1. Let _methodDef_ be DefineMethod of |MethodDefinition| with argument _homeObject_.
      1. ReturnIfAbrupt(_methodDef_).
      1. <del>Perform SetFunctionName(_methodDef_.[[Closure]], _methodDef_.[[Key]]).</del>
      1. <del>Let _desc_ be the PropertyDescriptor{[[Value]]: _methodDef_.[[Closure]], [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true*}.</del>
      1. Return <del>? DefinePropertyOrThrow(_homeObject_, _methodDef_.[[Key]], _desc_).</del><ins>DefaultMethodDescriptor(_methodDef_.[[Key]], _methodDef_.[[Closure]], _enumerable_, _placement_).</ins>
    </emu-alg>
    <emu-grammar>MethodDefinition : `get` ClassElementName `(` `)` `{` FunctionBody `}`</emu-grammar>
    <emu-alg>
      1. Let _key_ be the result of evaluating |ClassElementName|.
      1. ReturnIfAbrupt(_key_).
      1. If the function code for this |MethodDefinition| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
      1. Let _scope_ be the running execution context's LexicalEnvironment.
      1. Let _formalParameterList_ be an instance of the production <emu-grammar>FormalParameters : [empty]</emu-grammar>.
      1. Let _closure_ be FunctionCreate(~Method~, _formalParameterList_, |FunctionBody|, _scope_, _strict_).
      1. Perform MakeMethod(_closure_, _homeObject_).
      1. Perform SetFunctionName(_closure_, _key_, `"get"`).
      1. <del>Let _desc_ be the PropertyDescriptor{[[Get]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true*}.</del>
      1. <del>Return ? DefinePropertyOrThrow(_homeObject_, _propKey_, _desc_).</del>
      1. <ins>If _key_ is a Private Name,</ins>
        1. <ins>Set _enumerable_ to *false*.</ins>
        1. <ins>Let _configurable_ be *false*.</ins>
        1. <ins>If _placement_ is `"prototype"`, set _placement_ to `"own"`.</ins>
      1. <ins>Else,</ins>
        1. <ins>Let _configurable_ be *true*.</ins>
      1. <ins>Let _desc_ be the PropertyDescriptor{[[Get]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: _configurable_}.</ins>
      1. <ins>Return the ElementDescriptor { [[Kind]]: `"method"`, [[Key]]: _key_, [[Descriptor]]: _desc_, [[Placement]]: _placement_ }</ins>
    </emu-alg>
    <emu-grammar>MethodDefinition : `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`</emu-grammar>
    <emu-alg>
      1. Let _key_ be the result of evaluating |ClassElementName|.
      1. ReturnIfAbrupt(_key_).
      1. If the function code for this |MethodDefinition| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
      1. Let _scope_ be the running execution context's LexicalEnvironment.
      1. Let _closure_ be FunctionCreate(~Method~, |PropertySetParameterList|, |FunctionBody|, _scope_, _strict_).
      1. Perform MakeMethod(_closure_, _homeObject_).
      1. Perform SetFunctionName(_closure_, _key_, `"set"`).
      1. <del>Let _desc_ be the PropertyDescriptor{[[Set]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true*}.</del>
      1. <del>Return ? DefinePropertyOrThrow(_homeObject_, _propKey_, _desc_).</del>
      1. <ins>If _key_ is a Private Name,</ins>
        1. <ins>Set _enumerable_ to *false*.</ins>
        1. <ins>Let _configurable_ be *false*.</ins>
        1. <ins>If _placement_ is `"prototype"`, set _placement_ to `"own"`.</ins>
      1. <ins>Else,</ins>
        1. <ins>Let _configurable_ be *true*.</ins>
      1. <ins>Let _desc_ be the PropertyDescriptor{[[Set]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: _configurable_}.</ins>
      1. <ins>Return the ElementDescriptor { [[Kind]]: `"method"`, [[Key]]: _key_, [[Descriptor]]: _desc_, [[Placement]]: _placement_ }</ins>
    </emu-alg>
    <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
    <emu-alg>
      1. Let _key_ be the result of evaluating |ClassElementName|.
      1. ReturnIfAbrupt(_key_).
      1. If the function code for this |GeneratorMethod| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
      1. Let _scope_ be the running execution context's LexicalEnvironment.
      1. Let _closure_ be GeneratorFunctionCreate(~Method~, |UniqueFormalParameters|, |GeneratorBody|, _scope_, _strict_).
      1. Perform MakeMethod(_closure_, _homeObject_).
      1. Let _prototype_ be ObjectCreate(%GeneratorPrototype%).
      1. Perform DefinePropertyOrThrow(_closure_, `"prototype"`, PropertyDescriptor{[[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false*}).
      1. <del>Perform SetFunctionName(_closure_, _propKey_).</del>
      1. <del>Let _desc_ be the PropertyDescriptor{[[Value]]: _closure_, [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true*}.</del>
      1. <del>Return ? DefinePropertyOrThrow(_homeObject_, _propKey_, _desc_).</del>
      1. <ins>Return DefaultMethodDescriptor(_key_, _closure_, _enumerable_, _placement_).</ins>
    </emu-alg>
    <emu-grammar>
      AsyncMethod : `async` [no LineTerminator here] ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
    </emu-grammar>
    <emu-alg>
      1. Let _key_ be the result of evaluating |ClassElementName|.
      1. ReturnIfAbrupt(_key_).
      1. If the function code for this |AsyncMethod| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
      1. Let _scope_ be the LexicalEnvironment of the running execution context.
      1. Let _closure_ be ! AsyncFunctionCreate(~Method~, |UniqueFormalParameters|, |AsyncFunctionBody|, _scope_, _strict_).
      1. Perform ! MakeMethod(_closure_, _homeObject_).
      1. <del>Perform ! SetFunctionName(_closure_, _key_).</ins>
      1. <del>Let _desc_ be the PropertyDescriptor{[[Value]]: _closure_, [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true*}.</ins>
      1. <del>Return ? DefinePropertyOrThrow(_homeObject_, _propKey_, _desc_).</ins>
      1. <ins>Return DefaultMethodDescriptor(_key_, _closure_, _enumerable_, _placement_).</ins>
    </emu-alg>

      <emu-grammar>
        AsyncGeneratorMethod : `async` [no LineTerminator here] `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. Let _key_ be the result of evaluating |ClassElementName|.
        1. ReturnIfAbrupt(_key_).
        1. If the function code for this |AsyncGeneratorMethod| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
        1. Let _scope_ be the running execution context's LexicalEnvironment.
        1. Let _closure_ be ! AsyncGeneratorFunctionCreate(~Method~, |UniqueFormalParameters|, |AsyncGeneratorBody|, _scope_, _strict_).
        1. Perform ! MakeMethod(_closure_, _object_).
        1. Let _prototype_ be ! ObjectCreate(%AsyncGeneratorPrototype%).
        1. Perform ! DefinePropertyOrThrow(_closure_, `"prototype"`, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. <del>Perform ! SetFunctionName(_closure_, _propKey_).</del>
        1. <del>Let _desc_ be PropertyDescriptor { [[Value]]: _closure_, [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.</del>
        1. <del>Return ? DefinePropertyOrThrow(_object_, _propKey_, _desc_).</del>
        1. <ins>Return DefaultMethodDescriptor(_key_, _closure_, _enumerable_, _placement_).</ins>
      </emu-alg>

  </emu-clause>

<emu-clause id="runtime-semantics-class-field-definition-evaluation">
  <h1>Runtime Semantics: ClassFieldDefinitionEvaluation</h1>

  <p>With parameters _placement_ and _homeObject_.</p>

  <emu-grammar>
    FieldDefinition : ClassElementName Initializer?
  </emu-grammar>
  <emu-alg>
    1. Let _fieldName_ be the result of evaluating |ClassElementName|.
    1. ReturnIfAbrupt(_fieldName_).
    1. If |Initializer_opt| is present,
      1. Let _lex_ be the Lexical Environment of the running execution context.
      1. Let _formalParameterList_ be an instance of the production <emu-grammar>FormalParameters : [empty]</emu-grammar>.
      1. Let _initializer_ be FunctionCreate(~Method~, _formalParameterList_, |Initializer|, _lex_, *true*).
      1. Perform MakeMethod(_initializer_, _homeObject_).
    1. Else,
      1. Let _initializer_ be ~empty~.
    1. If _key_ is a Private Name,
      1. Let _enumerable_ be *false*.
      1. Let _configurable_ be *false*.
      1. Let _writable_ be *false*.
    1. Else,
      1. Let _enumerable_ be *true*.
      1. Let _configurable_ be *true*.
      1. Let _writable_ be *true*.
    1. Let _desc_ be the PropertyDescriptor{[[Value]]: _initializer_, [[Writable]]: _writable_, [[Enumerable]]: _enumerable_, [[Configurable]]: _configurable_}.
    1. Return an ElementDescriptor {
         [[Kind]]: `"field"`,
         [[Key]]: _fieldName_,
         [[Initializer]]: _initializer_,
         [[Descriptor]]: _desc_
         [[Placement]]: _placement_,
       }.
  </emu-alg>
</emu-clause>


  <!-- es6num="14.5.15" -->
  <emu-clause id="sec-runtime-semantics-bindingclassdeclarationevaluation" aoid="BindingClassDeclarationEvaluation">
    <h1>Runtime Semantics: BindingClassDeclarationEvaluation</h1>
    <emu-grammar>ClassDeclaration : <ins>DecoratorList?</ins> `class` BindingIdentifier ClassTail</emu-grammar>
    <emu-alg>
      1. <ins>If |DecoratorList_opt| is present, let _decorators_ be the result of performing DecoratorListEvaluation of |DecoratorList|.</ins>
      1. <ins>Otherwise, let _decorators_ be a new empty List.</ins>
      1. Let _className_ be StringValue of |BindingIdentifier|.
      1. Let _value_ be the result of ClassDefinitionEvaluation of |ClassTail| with arguments _className_<ins> and _decorators</ins>.
      1. ReturnIfAbrupt(_value_).
      1. Let _hasNameProperty_ be ? HasOwnProperty(_value_, `"name"`).
      1. If _hasNameProperty_ is *false*, perform SetFunctionName(_value_, _className_).
      1. Let _env_ be the running execution context's LexicalEnvironment.
      1. Perform ? InitializeBoundName(_className_, _value_, _env_).
      1. Return _value_.
    </emu-alg>
    <emu-grammar>ClassDeclaration : <ins>DecoratorList?</ins> `class` ClassTail</emu-grammar>
    <emu-alg>
      1. <ins>If |DecoratorList| is present, let _decorators_ be the result of performing DecoratorListEvaluation of |DecoratorList|.</ins>
      1. <ins>Otherwise, let _decorators_ be a new empty List.</ins>
      1. Return the result of ClassDefinitionEvaluation of |ClassTail| with arguments *undefined* <ins>and _decorators_</ins>.
    </emu-alg>
    <emu-note>
      <p><emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar> only occurs as part of an |ExportDeclaration| and the setting of a name property and establishing its binding are handled as part of the evaluation action for that production. See <emu-xref href="#sec-exports-runtime-semantics-evaluation"></emu-xref>.</p>
    </emu-note>
  </emu-clause>

  <!-- es6num="14.5.16" -->
  <emu-clause id="sec-class-definitions-runtime-semantics-evaluation">
    <h1>Runtime Semantics: Evaluation</h1>
    <emu-grammar>ClassDeclaration : <ins>DecoratorList?</ins> `class` BindingIdentifier ClassTail</emu-grammar>
    <emu-alg>
      1. Perform ? BindingClassDeclarationEvaluation of this |ClassDeclaration|.
      1. Return NormalCompletion(~empty~).
    </emu-alg>
    <emu-note>
      <p><emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar> only occurs as part of an |ExportDeclaration| and is never directly evaluated.</p>
    </emu-note>
    <emu-grammar>ClassExpression : <ins>DecoratorList?</ins> `class` BindingIdentifier? ClassTail</emu-grammar>
    <emu-alg>
      1. <ins>If |DecoratorList_opt| is present, let _decorators_ be the result of performing DecoratorListEvaluation of |DecoratorList|.</ins>
      1. <ins>Otherwise, let _decorators_ be a new empty List.</ins>
      1. If |BindingIdentifier_opt| is not present, let _className_ be *undefined*.
      1. Else, let _className_ be StringValue of |BindingIdentifier|.
      1. Let _value_ be the result of ClassDefinitionEvaluation of |ClassTail| with argument _className_ <ins>and _decorators_</ins>.
      1. ReturnIfAbrupt(_value_).
      1. If _className_ is not *undefined*, then
        1. Let _hasNameProperty_ be ? HasOwnProperty(_value_, `"name"`).
        1. If _hasNameProperty_ is *false*, then
          1. Perform SetFunctionName(_value_, _className_).
      1. Return NormalCompletion(_value_).
    </emu-alg>
    <emu-note>
      <p>If the class definition included a `name` static method then that method is not over-written with a `name` data property for the class name.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-coalesce-getter-setter" aoid=CoalesceGetterSetter>
    <h1>CoalesceGetterSetter ( _element_, _other_ )</h1>
    <emu-alg>
      1. Assert: _element_ and _other_ are both ElementDescriptor Records.
      1. Assert: IsAccessorDescriptor(_other_.[[Descriptor]]) and IsAccessorDescriptor(_element_.[[Descriptor]]) are both *true*,
      1. If _element_.[[Descriptor]] has a [[Get]] field,
        1. Set _other_.[[Descriptor]].[[Get]] to _element_.[[Descriptor]].[[Get]].
      1. Otherwise,
        1. Assert: _element_.[[Descriptor]] has a [[Set]] field.
        1. Set _other_.[[Descriptor]].[[Set]] to _element_.[[Descriptor]].[[Set]].
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-coalesce-class-elements" aoid="CoalesceClassElements">
    <h1>CoalesceClassElements ( _elements_ )</h1>
    <emu-alg>
      1. Assert: _elements_ is a List of ElementDescriptor Records.
      1. Let _newElements_ be an empty List.
      1. For _element_ in _elements_,
        1. If _element_.[[Kind]] is `"method"` or `"accessor"`, and _newElements_ contains a Record _other_ where _other_.[[Kind]] is `"method"` or `"accessor"`, _other_.[[Key]] is _element_.[[Key]], and _other_.[[Placement]] is _element_.[[Placement]],
          1. If IsDataDescriptor(_element_.[[Descriptor]]) is *true* or IsDataDescriptor(_other_.[[Descriptor]]) is *true*, then
            1. Assert: _element_.[[Key]] is not a Private Name.
            1. Assert: _element_.[[Descriptor]].[[Configurable]] is *true*, and _other_.[[Descriptor]].[[Configurable]] is *true*.
            1. If _element_.[[Decorators]] is present or _other_.[[Decorators]] is present, throw a *TypeError* exception.
            1. Set _other_.[[Descriptor]] to _element_.[[Descriptor]].
          1. Else,
            1. If _element_.[[Decorators]] is present,
              1. If _other_.[[Decorators]] is present, throw a *TypeError* exception.
              1. Set _other_.[[Decorators]] to _element_.[[Decorators]].
            1. Perform ! CoalesceGetterSetter(_element_, _other_).
        1. Otherwise, append _element_ to _newElements_.
      1. Return _newElements_.
    </emu-alg>
    <emu-note>In the case of public class elements, coalescing corresponds in semantics to ValidateAndApplyPropertyDescriptor. Note that this algorithm only coalesces method and accessor declarations, and it leaves field declarations as is.</emu-note>
  </emu-clause>

<emu-clause id="sec-define-field">
  <h1>DefineField(_receiver_, _descriptor_)</h1>
    <emu-alg>
    1. Assert: Type(_receiver_) is Object.
    1. Assert: _descriptor_ is an ElementDescriptor Record.
    1. Let _key_ be _descriptor_.[[Key]].
    1. Let _initializer_ be _fieldRecord_.[[Initializer]].
    1. If _initializer_ is not ~empty~, then
      1. Let _initValue_ be ? Call(_initializer_, _receiver_).
    1. Else, let _initValue_ be *undefined*.
    1. Assert: IsDataDescriptor(_descriptor_) is *true*.
    1. Let _dataDescriptor_ be a PropertyDescriptor with the fields of _descriptor_, but with the [[Value]] field set to _initValue_.
    1. If _fieldName_ is a Private Record,
      1. Perform ? PrivateFieldDefine(_key_, _receiver_, _dataDescriptor_).
    1. Else,
      1. Assert: IsPropertyKey(_fieldName_) is *true*.
      1. Perform ? DefinePropertyOrThrow(_receiver_, _key_, _dataDescriptor_).
    1. Return.
    </emu-alg>
</emu-clause>

<emu-clause id="sec-privatefielddefine" aoid="PrivateFieldDefine">
  <h1>PrivateFieldDefine (_P_, _O_, _desc_)</h1>
  <emu-alg>
    1. Assert: _P_ is a Private Name value.
    1. Assert: _desc_ is a Property Descriptor.
    1. If _O_ is not an object, throw a *TypeError* exception.
    1. Let _entry_ be PrivateFieldFind(_P_, _O_).
    1. If _entry_ is not ~empty~, throw a *TypeError* exception.
    1. Append { [[PrivateName]]: P, [[PrivateFieldDescriptor]]: _desc_ } to _O_.[[PrivateFieldDescriptors]].
</emu-clause>

<emu-clause id="initialize-public-instance-elements" aoid="InitializeInstanceFields">
  <h1>InitializeInstanceElements ( _O_, _constructor_ )</h1>

  <emu-alg>
    1. Assert: Type ( _O_ ) is Object.
    1. Assert: Assert _constructor_ is an ECMAScript function object.
    1. Let _elements_ be the value of _F_'s [[Elements]] internal slot.
    1. If _constructor_.[[PrivateBrand]] is not *undefined*,
      1. Perform ? PrivateBrandAdd(_O_, _constructor_.[[PrivateBrand]]).
    1. <ins>For each item _element_ in order from _elements_,</ins>
      1. <ins>If _element_.[[Placement]] is `"own"`, _element_.[[Kind]] is `"method"` or `"accessor"`, and _element_.[[Key]] is a Property Key,</ins>
        1. <ins>Perform ? DefinePropertyOrThrow(_O_, _element_.[[Key]], _element_.[[Descriptor]]).</ins>
    1. For each item _element_ in order from _elements_,
      1. If _element_.[[Placement]] is `"own"` and _element_.[[Kind]] is `"field"`,
        1. Perform ? DefineField(_O_, _element_).
      1. <ins>If _element_.[[Kind]] is `"hook"` and _element_.[[Placement]] is `"own"`,</ins>
        1. <ins>Let _res_ be ? Call(_element_.[[Start]], _O_).</ins>
        1. <ins>If _res_ is not *undefined*, throw a *TypeError* exception.</ins>
    1. Return.
  </emu-alg>
</emu-clause>

<emu-clause id="initialize-class-elements" aoid="InitializeClassElements">
  <h1>InitializeClassElements(_F_, _proto_)</h1>
  <emu-alg>
    1. Assert: Type(_F_) is Object and Type(_proto_) is Object.
    1. Assert: _F_ is an ECMAScript function object.
    1. Assert: _proto_ is ! Get(_F_, `"prototype"`).
    1. Let _elements_ be the value of _F_'s [[Elements]] internal slot.
    1. If _elements_ contains an _element_ such that _element_.[[Placement]] is `"static"`, _element_ has a [[Key]] field, and _element_.[[Key]] is a Private Name,
      1. Perform ? PrivateBrandAdd(_F_, _F_).
    1. For each item _element_ in order from _elements_,
      1. If _element_.[[Kind]] is `"method"` or `"accessor"`, _element_.[[Placement]] is `"static"` or `"prototype"`, and _element_.[[Key]] is not a Private Name,
        1. Let _receiver_ be _F_ if _element_.[[Placement]] is `"static"`, else let _receiver_ be _proto_.
        1. Perform ? DefinePropertyOrThrow(_receiver_, _element_.[[Key]], _element_.[[Descriptor]]).
    1. For each item _element_ in order from _elements_,
      1. If _element_.[[Kind]] is `"field"` and _element_.[[Placement]] is `"static"` or `"prototype"`,
        1. Assert: _element_.[[Descriptor]] does not have a [[Value]], [[Get]] or [[Set]] slot.
        1. Let _receiver_ be _F_ if _element_.[[Placement]] is `"static"`, else let _receiver_ be _proto_.
        1. Perform ? DefineField(_receiver_, _element_).
      1. If _element_.[[Placement]] is `"prototype"` or `"static"` and _element_.[[Kind]] is `"hook"`,
        1. Let _receiver_ be _F_ if _element_.[[Placement]] is `"static"`, else let _receiver_ be _proto_.
        1. Let _res_ be ? Call(_element_.[[Start]], _receiver_).
        1. If _res_ is not *undefined*, throw a *TypeError* exception.
    1. For each item _element_ in order from _elements_,
      1. If _element_.[[Placement]] is `"prototype"` or `"static"`, _element_.[[Kind]] is `"hook"`,
        1. If _element_ has a [[Replace]] field,
          1. Assert: _element_.[[Placement]] is `"static"`.
          1. Let _newConstructor_ be Call( _element_.[[Replace]], *undefined*, « _F_ »).
          1. If IsConstructor(_newConstructor_) is *false*, throw a *TypeError* exception.
          1. Set _F_ to _newConstructor_.
        1. If _element_ has a [[Finish]] field,
          1. Let _receiver_ be _F_ if _element_.[[Placement]] is `"static"`, else let _receiver_ be _proto_.
          1. Let _res_ be ? Call(_element_.[[Finish]], _receiver_).
          1. If _res_ is not *undefined*, throw a *TypeError* exception.
    1. Return _F_.
  </emu-alg>
  <emu-note type=editor>Brands, methods and accessors are added before initializers so that all methods are visible from all initializers</emu-note>
</emu-clause>

<emu-clause id="sec-assign-private-names" aoid=AssignPrivateNames>
  <h1>AssignPrivateNames ( _elements_ )</h1>
  <emu-alg>
    1. For each _element_ of _elements_,
      1. If _element_ has a [[Key]] field and _element_.[[Key]] is a Private Name,
        1. Let _name_ be _element_.[[Key]].
        1. If _name_ does not have a [[Type]] field, throw a *TypeError* exception.
        1. If _element_.[[Kind]] is `"field"`,
          1. Set _name_.[[Type]] to ~field~.
        1. Otherwise, if _element_.[[Kind]] is `"method"`,
          1. Set _name_.[[Type]] to ~method~.
        1. Otherwise, _element_.[[Kind]] is `"accessor"`,
          1. Set _name_.[[Type]] to ~accessor~.
        1. Set _name_.[[Descriptor]] to _element_.[[Descriptor]].
  </emu-alg>
</emu-clause>

</emu-clause>


</emu-clause>

  <emu-clause id="sec-private-names">
    <h1>Private Names and references</h1>

    <emu-note type=editor>
      This section refers to <a href="https://tc39.github.io/proposal-class-fields/#sec-private-names">Private Name values</a>, as defined in the class fields proposal.
    </emu-note>

<emu-clause id="sec-privatefieldget" aoid="PrivateFieldGet">
  <h1>PrivateFieldGet (_P_, _O_ )</h1>
  <emu-alg>
    1. Assert: _P_ is a Private Name value.
    1. If _O_ is not an object, throw a *TypeError* exception.
    1. Let _descriptor_ be _P_'s associated [[Descriptor]].
    1. If _descriptor_.[[Type]] is ~field~,
      1. Let _entry_ be PrivateFieldFind(_P_, _O_).
      1. If _entry_ is ~empty~, throw a *TypeError* exception.
      1. Return _entry_.[[PrivateFieldValue]].
    1. Perform ? PrivateBrandCheck(_O_, _P_).
    1. If _descriptor_.[[Type]] is ~method~,
      1. <ins>If _descriptor_.[[Descriptor]].[[Writable]] is *true*,</ins>
        1. <ins>Let _entry_ be PrivateFieldFind(_P_, _O_).</ins>
        1. <ins>If _entry_ is not ~empty~,</ins>
          1. <ins>Return _entry_.[[PrivateFieldValue]].</ins>
      1. Return _descriptor_.[[Value]].
    1. Otherwise, _descriptor_.[[Type]] is ~accessor~,
      1. If _descriptor_ does not have a [[Get]] field, throw a *TypeError* exception.
      1. Let _getter_ be _descriptor_.[[Get]].
      1. Return ? Call(_getter_, _O_).
  </emu-alg>
</emu-clause>

<emu-clause id="sec-privatefieldset" aoid="PrivateFieldSet">
  <h1>PrivateFieldSet (_P_, _O_, _value_ )</h1>
  <emu-alg>
    1. Assert: _P_ is a Private Name value.
    1. If _O_ is not an object, throw a *TypeError* exception.
    1. Let _descriptor_ be _P_'s associated [[Descriptor]].
    1. If _descriptor_.[[Type]] is ~field~,
      1. <ins>If _descriptor_.[[Descriptor]].[[Writable]] is *false*, throw a *TypeError* exception.</ins>
      1. Let _entry_ be PrivateFieldFind(_P_, _O_).
      1. If _entry_ is ~empty~, throw a *TypeError* exception.
      1. Set _entry_.[[PrivateFieldValue]] to _value_.
      1. Return.
    1. If _descriptor_.[[Type]] is ~method~,
      1. <ins>If _descriptor_.[[Descriptor]].[[Writable]] is *false*,</ins>
        1. Throw a *TypeError* exception.
      1. <ins>Otherwise,</ins>
        1. <ins>Let _entry_ be PrivateFieldFind(_P_, _O_).</ins>
        1. <ins>If _entry_ is ~empty~,</ins>
          1. <ins>Append { [[PrivateRecord]]: P, [[PrivateFieldValue]]: _value_ } to _O_.[[PrivateFieldValues]].</ins>
        1. <ins>Otherwise,</ins>
          1. <ins>Set _entry_.[[PrivateFieldValue]] to _value_.</ins>
        1. <ins>Return.</ins>
    1. Otherwise, _descriptor_.[[Type]] is ~accessor~,
      1. If _O_.[[PrivateFieldBrands]] does not contain _descriptor_.[[Brand]], throw a *TypeError* exception.
      1. If _descriptor_ does not have a [[Set]] field, throw a *TypeError* exception.
      1. Let _setter_ be _descriptor_.[[Set]].
      1. Perform ? Call(_setter_, _O_, _value_).
      1. Return.
  </emu-alg>
</emu-clause>

  <emu-clause id="sec-private-name-objects">
    <h1>Private Name Objects</h1>
    <emu-clause id="sec-private-name-constructor">
      <h1>The %PrivateName% Constructor</h1>
      <p>The Private Name constructor is the <dfn>%PrivateName%</dfn> intrinsic object. The %PrivateName% intrinsic does not have a global name or appear as a property of the global object.</p>
      <p>The PrivateName object is <em>deeply frozen</em>, in the sense that it is frozen, all objects reachable from it are frozen, and PrivateName instances are frozen as well. See the logic in CreateIntrinsics for details.</p>

      <emu-clause id="sec-private-description" aoid=PrivateName>
        <h1>%PrivateName% ( )</h1>
        <p>When %PrivateName% is called, the following steps are taken:</p>
        <emu-alg>
          1. Throw a *TypeError* exception.
        </emu-alg>
        <emu-note>New PrivateName instances can be created by decorating private class elements.</emu-note>
      </emu-clause>

      <emu-clause id="sec-private-name-object" aoid=PrivateNameObject>
        <h1>PrivateNameObject ( _name_ )</h1>
        <p>When PrivateNameObject is called with Private Name _name_, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be ? ObjectCreate(%PrivateNamePrototype%, &laquo; [[PrivateNameData]] &raquo;).
          1. Set _O_.[[PrivateNameData]] to _name_.
          1. Perform ! SetIntegrityLevel(_O_, `"frozen"`).
          1. Return _O_.
        </emu-alg>
      </emu-clause>

    <emu-clause id="sec-properties-of-the-private-name-prototype-object">
      <h1>Properties of the %PrivateNamePrototype% Object</h1>
      <p>The %PrivateNamePrototype% object is an ordinary object. It is not a %PrivateName% instance and does not have a [[PrivateNameData]] internal slot.</p>

      <emu-clause id="sec-private-name.prototype.constructor">
        <h1>%PrivateName%.prototype.constructor</h1>
        <p>The initial value of `PrivateName.prototype.constructor` is the intrinsic object %PrivateName%.</p>
      </emu-clause>

      <emu-clause id="sec-private-name-get">
        <h1>%PrivateName%.prototype.get ( _object_ )</h1>
        <p>When invoked, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _pn_ be ? GetPrivateName(_O_).
          1. If Type(_object_) is not Object, throw a *TypeError* exception.
          1. Return ? PrivateFieldGet(_pn_, _object_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-private-name-set">
        <h1>%PrivateName%.prototype.set ( _object_, _value_ )</h1>
        <p>%PrivateNameSet% is a per-realm built-in function object. When invoked, the following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _pn_ be ? GetPrivateName(_O_).
          1. If Type(_object_) is not Object, throw a *TypeError* exception.
          1. Return ? PrivateFieldSet(_pn_, _object_, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-private-name.prototype.description">
        <h1>get %PrivateName%.prototype.description ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _pn_ be ? GetPrivateName(_O_).
          1. Let _desc_ be _pn_'s [[Description]] value.
          1. If _desc_ is *undefined*, return the empty string.
          1. Otherwise, return _desc_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-private-name.prototype.tostring">
        <h1>%PrivateName%.prototype.toString ( )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Throw a *TypeError* exception.
        </emu-alg>
        <emu-note>
          Because conversion to a string throws, ToPropertyKey applied to a %PrivateName% object throws as well. This property is important to ensure that Private Names are not incorrectly used by decorators using property access, rather than with their `get` and `set` methods.
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-private-name.prototype-@@tostringtag">
        <h1>PrivateName.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value `"PrivateName"`.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-private-name-this-private-name" aoid=ThisPrivateName>
        <h1>GetPrivateName ( _O_ )</h1>
        <emu-alg>
          1. If Type(_O_) is not Object, throw a *TypeError* exception.
          1. If _O_ does not have a [[PrivateNameData]] internal slot, throw a *TypeError* exception.
          1. Return _O_.[[PrivateNameData]].
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-private-name-instances">
      <h1>Properties of PrivateName Instances</h1>
      <p>PrivateName instances are ordinary objects that inherit properties from the PrivateName prototype object. PrivateName instances have a [[PrivateNameData]] internal slot. The [[PrivateNameData]] internal slot is the Private Name value represented by this Private Name object.</p>
    </emu-clause>
    </emu-clause>
  </emu-clause>

    <emu-clause id="sec-createintrinsics" aoid="CreateIntrinsics">
      <h1>CreateIntrinsics ( _realmRec_ )</h1>
      <p>The abstract operation CreateIntrinsics with argument _realmRec_ performs the following steps:</p>
      <emu-alg>
        1. Let _intrinsics_ be a new Record.
        1. Set _realmRec_.[[Intrinsics]] to _intrinsics_.
        1. Let _objProto_ be ObjectCreate(*null*).
        1. Set _intrinsics_.[[%ObjectPrototype%]] to _objProto_.
        1. Let _throwerSteps_ be the algorithm steps specified in <emu-xref href="#sec-%throwtypeerror%"></emu-xref> for the %ThrowTypeError% function.
        1. Let _thrower_ be CreateBuiltinFunction(_throwerSteps_, &laquo; &raquo;, _realmRec_, *null*).
        1. Set _intrinsics_.[[%ThrowTypeError%]] to _thrower_.
        1. Let _noSteps_ be an empty sequence of algorithm steps.
        1. Let _funcProto_ be CreateBuiltinFunction(_noSteps_, &laquo; &raquo;, _realmRec_, _objProto_).
        1. Set _intrinsics_.[[%FunctionPrototype%]] to _funcProto_.
        1. Call _thrower_.[[SetPrototypeOf]](_funcProto_).
        1. Perform AddRestrictedFunctionProperties(_funcProto_, _realmRec_).
        1. Set fields of _intrinsics_ with the values listed in <emu-xref href="#table-7"></emu-xref> that have not already been handled above. The field names are the names listed in column one of the table. The value of each field is a new object value fully and recursively populated with property values as defined by the specification of each object in clauses 18-26. All object property values are newly created object values. All values that are built-in function objects are created by performing CreateBuiltinFunction(&lt;steps&gt;, &lt;slots&gt;, _realmRec_, &lt;prototype&gt;) where &lt;steps&gt; is the definition of that function provided by this specification, &lt;slots&gt; is a list of the names, if any, of the function's specified internal slots, and &lt;prototype&gt; is the specified value of the function's [[Prototype]] internal slot. The creation of the intrinsics and their properties must be ordered to avoid any dependencies upon objects that have not yet been created.
        1. <ins>For each property of %PrivateNamePrototype%, do<ins>
          1. <ins>Let _desc_ be the data property descriptor for this property.</ins>
          1. <ins>If _desc_ has a [[Get]], [[Set]], or [[Value]] field, then for each value _value_ of such fields,</ins>
            1. <ins>Perform ! SetIntegrityLevel(_value_, `"frozen"`).</ins>
        1. <ins>Perform ! SetIntegrityLevel(%PrivateNamePrototype%, `"frozen"`).</ins>
        1. <ins>Assert: The only own property of %PrivateName% is the `"prototype"` property, whose [[Value]] is %PrivateNamePrototype%.
        1. <ins>Perform ! SetIntegrityLevel(%PrivateName%, `"frozen"`).</ins>
        1. Return _intrinsics_.
      </emu-alg>
    </emu-clause>
</emu-clause>

<emu-clause id="decorator-semantics">
  <h1>Decorator semantics</h1>
  <emu-clause id=sec-decorator-functions>
    <h1>Decorator Functions</h1>
    <p>A <dfn>decorator function</dfn> is a function that takes and returns either a element descriptor or a class descriptor. The body of a decorator function modifies and returns the descriptor it receives to change the semantics of the decorated entity. Descriptor types can be differentiated by their `kind` property, which is either `"method"`, `"accessor"`, `"field"`, or `"class"`. Descriptors also have a @@toStringTag property which has the value `"Descriptor"`; this property helps differentiate them from other objects.</p>
    <emu-clause id=sec-decorator-functions-element-descriptor>
      <h1>Element Descriptors</h1>
      <p>An <dfn>element descriptor</dfn> describes an element of a class or object literal and has the following shape:</p>
      <pre><code class=typescript>
        interface ElementDescriptor {
          kind: "method", "accessor", "hook", or "field"
          key: String, Symbol or Private Name,
          placement: "static", "prototype", or "own"
          ...PropertyDescriptor,
          initializer?: Function
          extras?: ElementDescriptor[]
          start?: (any): undefined;
          register?: (klass): undefined;
          replace?: (klass): constructor;
        }
      </code></pre>
      The `start`, `register`, `replace` and `extra` fields are only present when returning from user code, and are not given as an argument to them, or logically part of the descriptor.
    </emu-clause>
    <emu-clause id=sec-decorator-functions-class-descriptor>
      <h1>Class Descriptors</h1>
      <p>A <dfn>class descriptor</dfn> describes a class and has the following shape:</p>
      <pre><code class=typescript>
        interface ClassDescriptor {
          kind: "class"
          elements: ElementDescriptor[]
          register?: (klass): undefined;
          replace?: (klass): constructor;
        }
      </code></pre>
    </emu-clause>
  </emu-clause>

    <emu-clause id=sec-decorator-runtime-semantics-decoratorevaluation aoid=DecoratorEvaluation>
      <h1>Runtime Semantics: DecoratorEvaluation</h1>
      <emu-grammar>Decorator : `@` DecoratorMemberExpression[?Yield]</emu-grammar>
      <emu-alg>
        1. Let _expr_ be the |MemberExpression| that is covered by |DecoratorMemberExpression|.
        1. Let _ref_ be the result of evaluating _expr_.
        1. Let _value_ be ? GetValue(_ref_).
        1. Return _value_.
      </emu-alg>
      <emu-grammar>Decorator : `@` DecoratorCallExpression[?Yield]</emu-grammar>
      <emu-alg>
        1. Let _expr_ be the result of reparsing |DecoratorCallExpression| as a |CallMemberExpression|.
        1. Let _ref_ be the result of evaluating _expr_.
        1. Let _value_ be ? GetValue(_ref_).
        1. Return _value_.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-method-definitions-runtime-semantics-decoratorlistevaluation aoid=DecoratorListEvaluation>
      <h1>Runtime Semantics: DecoratorListEvaluation</h1>
      <emu-grammar>DecoratorList : DecoratorList[?Yield]? Decorator[?Yield]</emu-grammar>
      <emu-alg>
        1. If |DecoratorList| is present, then let _leftValue_ be ? DecoratorListEvaluation(|DecoratorList|).
        1. Else, let _leftValue_ be a new empty List.
        1. Let _rightValue_ be ? DecoratorEvaluation(|Decorator|).
        1. Append _rightValue_ to the end of _leftValue_.
        1. Return _leftValue_.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-decorate-class aoid=DecorateClass>
      <h1>DecorateClass ( _elements_, _decorators_ )</h1>
      <emu-alg>
        1. Let _newElements_ be a new empty List.
        1. Let _placements_ be the Record { [[StaticKeys]]: « », [[PrototypeKeys]]: « », [[OwnKeys]]: « » }.
        1. For each _element_ in _elements_, do
          1. Perform ? AddElementPlacement(_element_, _placements_, *true*).
        1. For each _element_ in _elements_, do
          1. Let _elements_ be ? DecorateElement(_element_, _placements_).
          1. Concatenate _elements_ onto _newElements_.
        1. Return ? DecorateConstructor(_newElements_, _decorators_).
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-decorate-element aoid=DecorateElement>
      <h1>DecorateElement ( _element_, _placements_ )</h1>
      <p>With parameters _element_, a Class Element, and _placements_:</p>
      <emu-alg>
        1. Let _extras_ be a new empty List.
        1. If _element_ has a [[Decorators]] field, then for each _decorator_ in _element_.[[Decorators]], in reverse list order do
          1. If _element_.[[Kind]] is `"hook"`, throw a *TypeError*.
          1. Perform RemoveElementPlacement(_element_, _placements_).
          1. Let _elementObject_ be ? FromElementDescriptor(_element_).
          1. Let _elementExtrasObject_ be ? Call(_decorator_, *undefined*, « _elementObject_ »).
          1. If _elementExtrasObject_ is *undefined*,
            1. Let _elementExtrasObject_ be _elementObject_.
          1. Otherwise, set _elementExtrasObject_ to ? ToObject(_elementExtrasObject_).
          1. Let _elementExtras_ be ? ToElementExtras(_elementExtrasObject_).
          1. Let _element_ be _elementExtras_.[[Element]].
          1. Perform ? AddElementPlacement(_element_, _placements_).
          1. Let _newExtras_ be _elementExtras_.[[Extras]]
          1. If _newExtras_ is not *undefined*, then
            1. For each _extra_ of _newExtras_, do
              1. Perform ? AddElementPlacement(_extra_, _placements_).
            1. Concatenate _newExtras_ onto _extras_.
        1. Append _element_ to the start of _extras_.
        1. Return _extras_.
      </emu-alg>
    </emu-clause>
    <emu-clause id=sec-decorate-constructor aoid=DecorateConstructor>
      <h1>DecorateConstructor ( _elements_, _decorators_ )</h1>
      <p>With parameters _elements_, a List of Class Elements, and _decorators_, a List of decorator functions.</p>
      <emu-alg>
        1. For each _decorator_ in _decorators_, in reverse list order do
          1. Let _obj_ be FromClassDescriptor(_elements_).
          1. Let _result_ be ? Call(_decorator_, *undefined*, « _obj_ »).
          1. If _result_ is *undefined*, let _result_ be _obj_.
          1. Otherwise, set _result_ to ? ToObject(_result_).
          1. Let _newElements_ be ? ToClassDescriptor(_result_).
          1. If _newElements_ is not *undefined*,
            1. Set _elements_ to _newElements_.
            1. If there are two class elements _a_ and _b_ in _elements_ such that all of the following are true:
              1. _a_.[[Kind]] is not `"hook"`
              1. _b_.[[Kind]] is not `"hook"`
              1. _a_.[[Key]] is _b_.[[Key]]
              1. _a_.[[Placement]] is _b_.[[Placement]]
            1. Then, throw a *TypeError* exception.
        1. Return the _elements_.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-add-element-placement aoid=AddElementPlacement>
      <h1>AddElementPlacement (_element_, _placements_ [, _silent_])</h1>
      <emu-alg>
          1. If _element_ does not have a [[Key]] field, return.
          1. If _element_.[[Placement]] is `"own"`, then
            1. Let _keys_ be _placements_.[[OwnKeys]].
          1. Else if _element_.[[Placement]] is `"static"`, then
            1. Let _keys_ be _placements_.[[StaticKeys]].
          1. Else,
            1. Assert: _element_.[[Placement]] is `"prototype"`.
            1. Let _keys_ be _placements_.[[PrototypeKeys]].
          1. If _element_.[[Key]] is an element of _keys_, then
            1. If _silent_ is not present or is *false*, throw a *TypeError* exception.
          1. Otherwise, append _element_.[[Key]] to _keys_.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-remove-element-placement aoid=RemoveElementPlacement>
      <h1>RemoveElementPlacement (_element_, _placements_)</h1>
      <emu-alg>
          1. If _element_ does not have a [[Key]] field, return.
          1. If _element_.[[Placement]] is `"own"`, then
            1. Let _keys_ be _placements_.[[OwnKeys]].
          1. Else if _element_.[[Placement]] is `"static"`, then
            1. Let _keys_ be _placements_.[[StaticKeys]].
          1. Else,
            1. Assert: _element_.[[Placement]] is `"prototype"`.
            1. Let _keys_ be _placements_.[[PrototypeKeys]].
          1. Assert: _element_.[[Key]] is an element of _keys_.
          1. Remove _element_.[[Key]] from _keys_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-from-element-descriptors" aoid=FromElementDescriptors>
      <h1>FromElementDescriptors ( _elements_ )</h1>
      <emu-alg>
          1. Assert: _elements_ is a List of ElementDescriptor Records.
          1. Let _elementObjects_ be a new empty List.
          1. For each _element_ in _elements_, do
            1. Append ! FromElementDescriptor(_element_) to _elementObjects_.
          1. Return ! CreateArrayFromList(_elementObjects_).
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-from-element-descriptor aoid=FromElementDescriptor>
      <h1>FromElementDescriptor ( _element_ )</h1>
      <emu-alg>
        1. Assert: _element_ is an ElementDescriptor Record.
        1. Let _obj_ be ! ObjectCreate(%ObjectPrototype%).
        1. Let _desc_ be PropertyDescriptor{ [[Value]]: `"Descriptor"`, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
        1. Perform ! DefinePropertyOrThrow(_obj_, @@toStringTag, _desc_).
        1. Perform ! CreateDataPropertyOrThrow(_obj_, `"kind"`, _element_.[[Kind]]).
        1. If _element_ has a [[Descriptor]] field,
          1. If _element_.[[Descriptor]] has a [[Value]] field, then
            1. Perform ! CreateDataProperty(_obj_, `"method"`, _element_.[[Descriptor]].[[Value]]).
          1. If _element_.[[Descriptor]] has a [[Writable]] field, then
            1. Perform ! CreateDataProperty(_obj_, `"writable"`, _element_.[[Descriptor]].[[Writable]]).
          1. If _element_.[[Descriptor]] has a [[Get]] field, then
            1. Perform ! CreateDataProperty(_obj_, `"get"`, _element_.[[Descriptor]].[[Get]]).
          1. If _element_.[[Descriptor]] has a [[Set]] field, then
            1. Perform ! CreateDataProperty(_obj_, `"set"`, _element_.[[Descriptor]].[[Set]]).
          1. If _element_.[[Descriptor]] has an [[Enumerable]] field, then
            1. Perform ! CreateDataProperty(_obj_, `"enumerable"`, _element_.[[Descriptor]].[[Enumerable]]).
          1. If _element_.[[Descriptor]] has a [[Configurable]] field, then
            1. Perform ! CreateDataProperty(_obj_, `"configurable"`, _element_.[[Descriptor]].[[Configurable]]).
        1. If _element_.[[Kind]] is `"method"`, `"accessor"`, or `"field"`,
          1. Let _key_ be _element_.[[Key]].
          1. If _key_ is a Private Name, set _key_ to ? PrivateNameObject(_key_).
          1. Perform ! CreateDataPropertyOrThrow(_obj_, `"key"`, _key_).

        1. Perform ! CreateDataPropertyOrThrow(_obj_, `"placement"`, _element_.[[Placement]]).
        1. If _element_.[[Kind]] is `"field"`,
          1. Let _initialize_ be _element_.[[Initializer]].
          1. If _initialize_ is ~empty~, set _initialize_ to *undefined*.
          1. Perform ! CreateDataPropertyOrThrow(_obj_, `"initialize"`, _initialize_).
        1. If _element_.[[Kind]] is `"hook"`,
          1. Let _start_ be _element_.[[Start]].
          1. Assert: _start_ is not ~empty~.
          1. Perform ! CreateDataPropertyOrThrow(_obj_, `"start"`, _start_).
        1. Return _obj_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-to-element-descriptors" aoid=ToElementDescriptors>
      <h1>ToElementDescriptors ( _elementObjects_ )</h1>
      <emu-alg>
        1. Assert: _elementObject_ is an ECMAScript language value.
        1. If _elementObjects_ is *undefined*, return *undefined*.
        1. Let _elements_ be a new empty List.
        1. Let _iteratorRecord_ be ? GetIterator(_elementObjects_).
        1. Repeat,
          1. Let _next_ be ? IteratorStep(_iteratorRecord_).
          1. If _next_ is false, return _elements_.
          1. Let _elementsObject_ be ? ToObject(? IteratorValue(_next_)).
          1. Let _element_ be ? ToElementDescriptor(_elementObject_).
          1. Let _extras_ be ? Get(_elementObject_, `"extras"`).
          1. If _extras_ is not *undefined*, throw a *TypeError* exception.
          1. Append _element_ to _elements_.
        1. If the above steps contained an abrupt completion _status_ outside of IteratorStep, return ? IteratorClose(iteratorRecord, status).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-to-decorator-property-descriptor" aoid=ToDecoratorPropertyDescriptor>
      <h1>ToDecoratorPropertyDescriptor ( _elementObject_ )</h1>
      <emu-alg>
        1. Let _desc_ be a new Property Descriptor that initially has no fields.
        1. Let _hasEnumerable_ be ? HasProperty(_Obj_, `"enumerable"`).
        1. If _hasEnumerable_ is *true*, then
          1. Let _enumerable_ be ToBoolean(? Get(_Obj_, `"enumerable"`)).
          1. Set _desc_.[[Enumerable]] to _enumerable_.
        1. Let _hasConfigurable_ be ? HasProperty(_Obj_, `"configurable"`).
        1. If _hasConfigurable_ is *true*, then
          1. Let _configurable_ be ToBoolean(? Get(_Obj_, `"configurable"`)).
          1. Set _desc_.[[Configurable]] to _configurable_.
        1. Let _hasValue_ be ? HasProperty(_Obj_, `"method"`).
        1. If _hasValue_ is *true*, then
          1. Let _value_ be ? Get(_Obj_, `"method"`).
          1. If IsCallable(_value_) is *false*, throw a *TypeError* exception.
          1. Set _desc_.[[Value]] to _value_.
        1. Let _hasWritable_ be ? HasProperty(_Obj_, `"writable"`).
        1. If _hasWritable_ is *true*, then
          1. Let _writable_ be ToBoolean(? Get(_Obj_, `"writable"`)).
          1. Set _desc_.[[Writable]] to _writable_.
        1. Let _hasGet_ be ? HasProperty(_Obj_, `"get"`).
        1. If _hasGet_ is *true*, then
          1. Let _getter_ be ? Get(_Obj_, `"get"`).
          1. If IsCallable(_getter_) is *false* and _getter_ is not *undefined*, throw a *TypeError* exception.
          1. Set _desc_.[[Get]] to _getter_.
        1. Let _hasSet_ be ? HasProperty(_Obj_, `"set"`).
        1. If _hasSet_ is *true*, then
          1. Let _setter_ be ? Get(_Obj_, `"set"`).
          1. If IsCallable(_setter_) is *false* and _setter_ is not *undefined*, throw a *TypeError* exception.
          1. Set _desc_.[[Set]] to _setter_.
        1. If _desc_.[[Get]] is present or _desc_.[[Set]] is present, then
          1. If _desc_.[[Value]] is present or _desc_.[[Writable]] is present, throw a *TypeError* exception.
        1. Return CompletePropertyDescriptor(_desc_).
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-to-element-descriptor aoid=ToElementDescriptor>
      <h1>ToElementDescriptor ( _elementObject_ )</h1>
      <p>With parameter _elementObject_, returns an ElementDescriptor.</p>
      <emu-alg>
        1. Assert: Type(_elementObject_) is Object.
        1. Let _kind_ be ? ToString(? Get(_elementObject_, `"kind"`)).
        1. If _kind_ is not one of `"hook"`, `"method"`, `"accessor"` or `"field"`, throw a *TypeError* exception.
        1. Let _key_ be ? Get(_elementObject_, `"key"`).
        1. If _kind_ is `"hook"`,
          1. If _key_ is not *undefined*, throw a *TypeError* exception.
        1. If _key_ has a [[PrivateNameData]] internal slot, set _key_ to _key_.[[PrivateNameData]].
        1. Otherwise, set _key_ to ? ToPropertyKey(_key_).
        1. Let _placement_ be ? ToString(? Get(_elementObject_, `"placement"`)).
        1. If _placement_ is not one of `"static"`, `"prototype"`, or `"own"`, throw a *TypeError* exception.
        1. Let _descriptor_ be ? ToDecoratorPropertyDescriptor(_elementObject_)
        1. If _key_ is a Private Name,
          1. If _descriptor_ has an [[Enumerable]] field and _descriptor_.[[Enumerable]] is *true*, throw a *TypeError* exception.
          1. If _descriptor_ has an [[Configurable]] field and _descriptor_.[[Configurable]] is *true*, throw a *TypeError* exception.
          1. If _placement_ is `"prototype"`, throw a *TypeError* exception.
        1. If _kind_ is `"accessor"` or `"hook"` and IsDataDescriptor(_descriptor_) is *true*, throw a *TypeError* exception.
        1. If _kind_ is `"field"`, `"method"` or `"hook"`, and IsAccessorDescriptor(_descriptor_) is *true*, throw a *TypeError* exception.
        1. If _kind_ is `"field"` and _descriptor_ has a [[Value]] field, throw a *TypeError* exception.
        1. Let _initialize_ be ? Get(_elementObject_, `"initialize"`).
        1. If _initialize_ is not *undefined* and IsCallable(_initialize_) is *false*, throw a *TypeError*.
        1. If _kind_ is not `"field"`,
          1. If _initializer_ is not *undefined*, throw a *TypeError* exception.
        1. Let _start_ be ? Get(_elementObject_, `"start"`).
        1. If _start_ is not *undefined* and IsCallable(_start_) is *false*, throw a *TypeError*.
        1. If _kind_ is not `"hook"`,
          1. If _start_ is not *undefined*, throw a *TypeError* exception.
        1. Let _replace_ be ? Get(_elementObject_, `"replace"`).
        1. If _replace_ is not *undefined* and IsCallable(_replace_) is *false*, throw a *TypeError*.
        1. If _kind_ is not `"hook"`,
          1. If _replace_ is not *undefined*, throw a *TypeError* exception.
        1. Let _finish_ be ? Get(_elementObject_, `"finish"`).
        1. If _finish_ is not *undefined* and IsCallable(_finish_) is *false*, throw a *TypeError*.
        1. If _kind_ is not `"hook"`,
          1. If _finish_ is not *undefined*, throw a *TypeError* exception.
        1. If _kind_ is `"hook"`,
          1. If _start_, _replace_ and _finish_ are all *undefined*, throw a *TypeError* exception.
          1. If neither _replace_ nor _finish_ are *undefined*, throw a *TypeError* exception.
        1. Let _elements_ be ? Get(_elementObject_, `"elements"`).
        1. If _elements_ is not *undefined*, throw a *TypeError* exception.
        1. Let _element_ be the ElementDescriptor { [[Kind]]: _kind_, [[Placement]]: _placement_ }.
        1. If _kind_ is `"method"`, `"accessor"`, or `"field",
           1. Set _element_.[[Key]] to _key_.
           1. Set _element_.[[Descriptor]] to _descriptor_.
        1. If _kind_ is `"field"`,
           1. Set _element_.[[Initializer]] to _initialize_.
        1. If _kind_ is `"hook"`,
           1. If _start_ is not *undefined*, set _element_.[[Start]] to _start_.
           1. If _replace_ is not *undefined*, set _element_.[[Replace]] to _replace_.
           1. If _finish_ is not *undefined*, set _element_.[[Finish]] to _replace_.
        1. Return _element_.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-to-element-extras aoid=ToElementExtras>
      <h1>ToElementExtras ( _elementObject_ )</h1>
      <p>With parameter _elementObject_, returns a Record containing three values: { [[Element]]: ElementDescriptor, [[Extras]]: an iterable of other Element Descriptors }.</p>
      <emu-alg>
        1. Assert: Type(_elementObject_) is Object.
        1. Let _element_ be ? ToElementDescriptor(_elementObject_).
        1. Let _extrasObject_ be ? Get(_elementObject_, `"extras"`).
        1. Let _extras_ be ? ToElementDescriptors(_extrasObject_).
        1. Return the Record { [[Element]]: _element_, [[Extras]]: _extras_ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-from-class-descriptor aoid=FromClassDescriptor>
      <h1>FromClassDescriptor ( _elements_ )</h1>
      <emu-alg>
        1. Assert: _elements_ is a List of ElementDescriptor Records.
        1. Let _elementsObjects_ be FromElementDescriptors(_elements_).
        1. Let _obj_ be ! ObjectCreate(%ObjectPrototype%).
        1. Let _desc_ be PropertyDescriptor{ [[Value]]: `"Descriptor"`, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
        1. Perform ! DefinePropertyOrThrow(_obj_, @@toStringTag, _desc_).
        1. Perform ! CreateDataPropertyOrThrow(_obj_, `"kind"`, `"class"`).
        1. Perform ! CreateDataPropertyOrThrow(_obj_, `"elements"`, _elementsObjects_).
        1. Return _obj_.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-to-class-descriptor aoid=ToClassDescriptor>
      <h1>ToClassDescriptor ( _classDescriptor_ )</h1>
      <emu-alg>
        1. Let _kind_ be ? ToString(? Get(_classDescriptor_, `"kind"`).
        1. If _kind_ is not `"class"`, throw a *TypeError* exception.
        1. Let _key_ be ? Get(_classDescriptor_, `"key"`).
        1. If _key_ is not *undefined*, throw a *TypeError* exception.
        1. Let _placement_ be ? Get(_classDescriptor_, `"placement"`).
        1. If _placement_ is not *undefined*, throw a *TypeError* exception.
        1. Let _descriptor_ be ? ToPropertyDescriptor(_classDescriptor_).
        1. If _descriptor_ has any fields, throw a *TypeError* exception.
        1. Let _initialize_ be ? Get(_classDescriptor_, `"initialize"`).
        1. If _initialize_ is not *undefined*, throw a *TypeError* exception.
        1. Let _start_ be ? Get(_classDescriptor_, `"start"`).
        1. If _start_ is not *undefined*, throw a *TypeError* exception.
        1. Let _extras_ be ? Get(_classDescriptor_, `"extras"`).
        1. If _extras_ is not *undefined*, throw a *TypeError* exception.
        1. Let _elementsObject_ be ? ToObject(? Get(_classDescriptor_, `"elements"`)).
        1. Return ? ToElementDescriptors(_elementsObject_).
      </emu-alg>
    </emu-clause>

  </emu-clause>
</emu-clause>
