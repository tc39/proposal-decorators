Decorators call agenda and notes
Tuesday, August 21, 2018, 17:00 UTC

Attendees:
* Bradley Meck (BF)‚Ä®
* Jordan Harband (JH)‚Ä®
* Ron Buckton (RB)‚Ä®
* Justin Ridgewell (JRL)‚Ä®
* Diego Ferreiro Val (DFV)‚Ä®

Agenda & notes:
* toString regardless of ordering‚Ä®
    * BF: No strong objection to including. Would not want it if it‚Äôs not a simple substring of the sourceText‚Ä®
    * RB: If it‚Äôs `@dec export`, either export is included or it‚Äôs excluded. Or we change what the grammar says is part of the toString. If export comes first, it‚Äôs a no brainer.‚Ä®
    * BF: I object to concatting.‚Ä®
    * RB: I agree.‚Ä®
    * JH: RB wants to not include them? And BF wants to include, but only if we don‚Äôt concat.‚Ä®
    * JRL: We could take it the other way, we could include export into exported class declarations. Then including export in `@dec export class X {}` isn‚Äôt a big deal.‚Ä®
    * RB: Having decorators in toString allows for eval case, and allows contextual information. Those are the real reasons to include. Both of those apply to including export.‚Ä®
    * BF: Does anyone feel that we need them in toString?‚Ä®
    * JH: I feel like we need to include them.‚Ä®
    * DFV: What decorators mean to a class and what export means to a class are very different.‚Ä®
    * JH: We disagree because we think static and export are very different things.‚Ä®
    * RB: Yes. And this comes from other languages that do this.‚Ä®
    * JH: I don‚Äôt think we‚Äôll make two independent decisions. We‚Äôll either have decorators before export, and include export. Or we‚Äôll have export then decorators, and we can include decorators in that case.‚Ä®
    * BF: I would need convincing to do a concat.‚Ä®
    * RB: The question that came up in the F12 debugger, can a debugger eval code that includes the export keyword?‚Ä®
    * BF: It can happen.‚Ä®
    * RB: but you said you inject export?‚Ä®
    * BF: No, just don‚Äôt want to concat. I just want a regular, single substring.‚Ä®
    * RB: My preferences are, don‚Äôt include. Then include the export in `@dec export`. Then concat if we can compromise.‚Ä®
    * JRL: If we do `@dec export`, could we just include export in class declaration?‚Ä®
    * JH: Export probably won‚Äôt go in toString. Concat probably won‚Äôt happen. My preference is `export @dec` and include decorators in toString. Or we do `@dec export` and decs aren‚Äôt included.‚Ä®
    * JRL: Why the strong dislike for including export?‚Ä®
    * JH: Because it‚Äôs not a value modifier.‚Ä®
    * RB: I think the issue here is that export looks like a modifier. It should be modifying the class.‚Ä®
    * ‚Ä¶ I took a break taking notes üò¨ ‚Ä¶ Lots of ‚Äúmental model‚Äù talk...‚Ä®
    * JH: We can take the two options to committee:‚Ä®
        1. Think of including export as a modifier‚Ä®
            * Include export in toString‚Ä®
            * Decorators before export‚Ä®
        2. Think of export as a module thing‚Ä®
            * Don‚Äôt include export in toString‚Ä®
            * Export before decorator‚Ä®
    * BF: That we can use export not on a declaration (` export { binding as name }`) means that it really can‚Äôt apply export as a modifier in every case. If we break the `export class X` into two statements, it would break the toString.‚Ä®
    * JRL: Do these other languages that use export as a modifier, do they also allow you to break up the export into an export and a declaration.‚Ä®
    * RB: I would have to see.‚Ä®
    * JRL: We can also disallow decorators on export keyword.‚Ä®
    * DFV and JH: That would force the hand of the ordering, because we would have to decide if toString is included in the broken class declaration.‚Ä®
    * RB and BF: We could do a user survey, but you have to be careful of bias.‚Ä®
    * RB: Typescript will conform to whatever ES decides.‚Ä®
    * JRL: What if using decorators completely censored to toString? Kinda like `[native code]`‚Ä®
    * JH: That would eliminate debuggability kind of like using `.bind`, but unlike bind, there are things that can‚Äôt be accomplished without decorators.‚Ä®
    * RB: I don‚Äôt think there‚Äôs value in censoring instead of just not including them.‚Ä®
    * JRL: We also haven‚Äôt discussed decorators on method‚Äôs toString. Are we basing that decision off of decorators on classes?‚Ä®
    * RB and JH: Yes.‚Ä®
    * JH: We‚Äôll propose adding static keyword to toString in MF‚Äôs toString proposal.‚Ä®
    * RB: Back to the survey, do we want to do that?‚Ä®
    * JRL: I think we‚Äôd need to include others in the discussion to do a survey.‚Ä®
    * BF: No opposition, but it‚Äôll mean a long time.‚Ä®
* Next Steps‚Ä®
    * JRL: What are our next steps?‚Ä®
    * RB: Need to discuss mental model approach?‚Ä®
    * JRL: Is this a discussion that needs to happen in another meeting, or on GitHub?‚Ä®
    * JH: I‚Äôm not sure we can convince the other in another meeting. We could propose including export in toString, and work from there?‚Ä®
    * JH: Also getting static included in toString.‚Ä®
    * JRL: Sounds like we can get the two mental model approach on GitHub, discuss all the changes necessary to support those models, and the pros/cons of them.‚Ä®
    * RB: One thing we can discuss: Does it make sense to decorate exports to change its behavior?‚Ä®
    * Next agenda will include decorating export.‚Ä®
    
- - - -

* **Decorating Export discussion on Github**
  * https://github.com/tc39/proposal-decorators/issues/135
* **Two mental model approach on Github**
  * @ljharb @rbuckton, please create an issue.
